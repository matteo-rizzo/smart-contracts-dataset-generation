import subprocess
from pathlib import Path


class SolidityCompiler:
    def __init__(self, console):
        """
        Initializes the SolidityCompiler with a console instance for logging.

        :param console: Rich console instance for logging.
        """
        self.console = console

    def compile_to_bytecode(self, sol_file: Path, output_folder: str, output_file: Path) -> None:
        """
        Compiles the Solidity file and saves the runtime bytecode to the specified output file.

        :param sol_file: Path to the Solidity file.
        :param output_folder: Directory to store the compiled output.
        :param output_file: The path where the final .hex bytecode file will be saved.
        :raises Exception: Raises an exception if bytecode generation fails.
        """
        output_folder = Path(output_folder)
        output_folder.mkdir(parents=True, exist_ok=True)

        # Create a temporary Solidity file for compilation
        temp_file = output_folder / f"{sol_file.stem}_temp.sol"
        try:
            # Copy the original Solidity file to the temporary file for compilation
            temp_file.write_text(sol_file.read_text())

            # Run the solc command to compile the code
            command = ["solc", "--bin-runtime", "-o", str(output_folder), "--overwrite", str(temp_file)]
            result = subprocess.run(command, capture_output=True, text=True)

            # Check if the compilation succeeded
            if result.returncode == 0:
                bin_runtime_file = output_folder / f"{sol_file.stem}.bin-runtime"
                if bin_runtime_file.exists():
                    bin_runtime_file.rename(output_file)
                    self.console.print(f"[bold green]Runtime bytecode saved to {output_file}.[/bold green]")
                else:
                    raise FileNotFoundError(f"Failed to locate generated bytecode for {sol_file}")
            else:
                raise Exception(f"Error generating runtime bytecode for {sol_file}:\n{result.stderr}")

        except Exception as e:
            self.console.print(f"[bold red]Error: {e}[/bold red]")
            raise

        finally:
            # Ensure the temporary file is deleted after processing
            if temp_file.exists():
                temp_file.unlink()
