from pathlib import Path

from rich.progress import track
from solcx import compile_files, install_solc, set_solc_version

from src.classes.conversion.FileManager import FileManager
from src.classes.conversion.PragmaParser import PragmaParser
from src.classes.conversion.SolcInstaller import SolcInstaller


class RuntimeGenerator:
    def __init__(self, console, installer: SolcInstaller, file_manager: FileManager):
        """
        Initialize the RuntimeGenerator with dependencies.

        :param console: Rich Console instance for logging output.
        :param installer: SolcInstaller instance to handle version management.
        :param file_manager: FileManager instance to manage file retrieval.
        """
        self.console = console
        self.installer = installer
        self.file_manager = file_manager

    def generate_runtime_bytecode(self, folder: str, output_folder: str) -> None:
        """
        Generates runtime bytecode for all Solidity files in a given folder.

        :param folder: Path to the folder containing Solidity (.sol) files.
        :param output_folder: Path to the folder where runtime bytecode (.hex) files will be saved.
        """
        self.console.print(f"[bold yellow]Scanning Solidity files in folder: {folder}[/bold yellow]")
        Path(output_folder).mkdir(parents=True, exist_ok=True)
        sol_files = self.file_manager.find_solidity_files(folder)

        if not sol_files:
            self.console.print(f"[bold red]No Solidity files found in {folder}.[/bold red]")
            return

        self.console.print(f"[bold blue]Found {len(sol_files)} Solidity file(s) to process[/bold blue]")

        for sol_file in track(sol_files, description="Generating runtime bytecode..."):
            try:
                # Parse pragma statements and select the highest version
                self.console.print(f"[bold yellow]Processing file: {sol_file.name}[/bold yellow]")
                highest_version = self._get_highest_version(sol_file)

                if not highest_version:
                    raise ValueError(f"No valid pragma versions found in {sol_file}")

                self.console.print(
                    f"[bold green]Highest pragma version found: {highest_version} for {sol_file.name}[/bold green]")

                # Attempt to generate bytecode using py-solc-x
                self._attempt_bytecode_generation(sol_file, output_folder, highest_version)
            except Exception as e:
                self.console.print(f"[bold red]Error while processing {sol_file.name}: {e}[/bold red]")

    @staticmethod
    def _get_highest_version(sol_file: Path) -> str:
        """
        Parses the Solidity file to extract the highest pragma version found.

        :param sol_file: Path to the Solidity file.
        :return: The highest version found in the pragma statements.
        """
        # Read the content of the file
        with open(sol_file, 'r') as file:
            content = file.read()

        # Extract pragma statements
        pragma_statements = PragmaParser.parse_pragma(content)

        if not pragma_statements:
            return ""

        # Sort the versions to find the highest one
        versions = [statement['version'] for statement in pragma_statements if 'version' in statement]
        if not versions:
            return ""

        # Return the highest version
        return max(versions, key=lambda v: list(map(int, v.split('.'))))

    def _attempt_bytecode_generation(self, sol_file: Path, output_folder: str, version: str) -> None:
        """
        Attempts to generate bytecode for the specified Solidity code using the highest version found.

        :param sol_file: Path to the Solidity file to compile.
        :param output_folder: Directory to store the generated bytecode.
        :param version: The Solidity version to use for compilation.
        """
        self.console.print(f"[bold cyan]Switching to Solidity version {version} for file: {sol_file.name}[/bold cyan]")
        self._install_and_set_solc_version(version)

        self.console.print(f"[bold yellow]Compiling {sol_file.name} to bytecode...[/bold yellow]")

        try:
            compiled_contracts = compile_files([str(sol_file)], output_values=["bin-runtime"])

            # Handle the compiled contracts and save all bytecode in a single output file
            self._handle_compiled_contracts(compiled_contracts, output_folder, sol_file)
        except Exception as e:
            self.console.print(f"[bold red]Failed to generate bytecode for {sol_file.name}: {e}[/bold red]")

    def _install_and_set_solc_version(self, version: str) -> None:
        """
        Installs and sets the specified Solidity version using py-solc-x.

        :param version: The Solidity version to install and set.
        """
        try:
            self.console.print(f"[bold cyan]Checking if Solidity version {version} is installed...[/bold cyan]")
            install_solc(version)
            set_solc_version(version)
            self.console.print(f"[bold green]Successfully set Solidity version to {version}[/bold green]")
        except Exception as e:
            raise RuntimeError(f"Failed to install or set Solidity version {version}: {e}")

    def _handle_compiled_contracts(self, compiled_contracts, output_folder, sol_file):
        """
        Handles the compiled contracts, saving all runtime bytecode from the Solidity file into one output file.

        :param compiled_contracts: Dictionary of compiled contracts and their bytecode.
        :param output_folder: Path to save the bytecode.
        :param sol_file: The original Solidity file being processed.
        """
        output_file = Path(output_folder) / f"{sol_file.stem}.hex"
        all_bytecode = ""

        for contract, data in compiled_contracts.items():
            bytecode = data.get('bin-runtime', '')

            if bytecode:
                # Concatenate all bytecode
                all_bytecode += bytecode + "\n"

        if all_bytecode:
            # Save the combined bytecode to the output file
            with open(output_file, 'w') as f:
                f.write(all_bytecode.strip())

            self.console.print(
                f"[bold green]All runtime bytecode saved for {sol_file.name} to {output_file}[/bold green]")
        else:
            self.console.print(f"[bold yellow]No bytecode generated for any contract in {sol_file.name}[/bold yellow]")
